import asyncio
import logging
import os
import time
from collections import defaultdict
from contextlib import asynccontextmanager
from functools import wraps

import httpx
from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import Command, CommandStart
from aiogram.types import Message
from aiogram.utils.markdown import hbold, hcode
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application
from aiohttp import web
from client import ZakupaiAPIClient, get_command_endpoint
from config import config
from db_simple import get_api_key, init_db, save_api_key
from error_handler import ErrorHandlingMiddleware
from prometheus_client import Counter, Gauge, Histogram, start_http_server

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Prometheus metrics setup
METRICS_PORT = int(os.getenv("PROMETHEUS_PORT", "8081"))
BOT_UP = Gauge("zakupai_bot_up", "ZakupAI bot process status")
BOT_COMMANDS_TOTAL = Counter(
    "zakupai_bot_commands_total", "Total commands processed", ["command"]
)
BOT_COMMAND_ERRORS_TOTAL = Counter(
    "zakupai_bot_command_errors_total", "Total command errors", ["command"]
)
BOT_COMMAND_DURATION_SECONDS = Histogram(
    "zakupai_bot_command_duration_seconds",
    "Command execution duration in seconds",
    ["command"],
)
BOT_LAST_ACTIVITY = Gauge(
    "zakupai_bot_last_activity_timestamp",
    "Unix timestamp of the last processed command",
)

start_http_server(METRICS_PORT)
ProcessCollector()  # adds process_* metrics
PlatformCollector() # adds platform_* metrics (CPU, mem, etc.)
BOT_UP.set(1)
BOT_LAST_ACTIVITY.set_to_current_time()

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
TOKEN = config.telegram.bot_token

# –í–∞–ª–∏–¥–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–∞ –≤ dev —Ä–µ–∂–∏–º–µ
if TOKEN.endswith("_") or "AAAA" in TOKEN:
    logger.warning(
        "‚ö†Ô∏è  –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è dev/placeholder —Ç–æ–∫–µ–Ω - –±–æ—Ç –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –≤ —Ä–µ–∂–∏–º–µ –∑–∞–≥–ª—É—à–∫–∏"
    )
    DEV_MODE = True
else:
    DEV_MODE = config.security.environment == "development"

bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()

# –ü–æ–¥–∫–ª—é—á–∞–µ–º middleware –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫
dp.message.middleware(ErrorHandlingMiddleware())

# API –∫–ª–∏–µ–Ω—Ç –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
api_client = ZakupaiAPIClient()

# –•—Ä–∞–Ω–∏–ª–∏—â–µ —Å–æ—Å—Ç–æ—è–Ω–∏–π –ø–æ–∏—Å–∫–∞ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
user_search_sessions = {}


def format_advanced_search_results(
    search_results: dict, query: str, filters: list[str]
) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –¥–ª—è Telegram (–∫–æ—Ä–æ—Ç–∫–∏–π —Ñ–æ—Ä–º–∞—Ç)
    """
    results = search_results.get("results", [])
    total_count = search_results.get("total_count", 0)

    if not results:
        return "‚ùå –õ–æ—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –ø–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É"

    # –ö—Ä–∞—Ç–∫–∏–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
    header = f"üîç –ù–∞–π–¥–µ–Ω–æ {total_count} –ª–æ—Ç(–æ–≤)"
    if filters:
        header += f" ({', '.join(filters)})"
    header += ":\n\n"

    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 3 –ª–æ—Ç–∞ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞
    formatted_results = []
    for i, lot in enumerate(results[:3], 1):
        lot_text = f"{i}. {lot.get('nameRu', '–ù–∞–∑–≤–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç')[:50]}..."
        lot_text += (
            f"\nüí∞ {lot.get('amount', 0):,.0f} —Ç–≥ | ID: {lot.get('id', 'N/A')}\n"
        )
        formatted_results.append(lot_text)

    # –ö—Ä–∞—Ç–∫–∏–π —Ñ—É—Ç–µ—Ä
    footer = ""
    if total_count > 3:
        footer = f"\n... –∏ –µ—â—ë {total_count - 3} –ª–æ—Ç(–æ–≤)"

    return header + "\n".join(formatted_results) + footer


# –†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã: webhook –∏–ª–∏ polling
USE_WEBHOOK = bool(
    config.telegram.webhook_url and config.security.environment != "development"
)


# Rate limiting —Å–∏—Å—Ç–µ–º–∞
class RateLimiter:
    """–ü—Ä–æ—Å—Ç–∞—è —Å–∏—Å—Ç–µ–º–∞ rate limiting –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç —Å–ø–∞–º–∞"""

    def __init__(self, max_requests: int = None, window_seconds: int = 60):
        self.max_requests = max_requests or config.security.max_requests_per_minute
        self.window_seconds = window_seconds
        self.requests: dict[int, list[float]] = defaultdict(list)

    def is_allowed(self, user_id: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Ä–∞–∑—Ä–µ—à–µ–Ω –ª–∏ –∑–∞–ø—Ä–æ—Å –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        now = time.time()
        user_requests = self.requests[user_id]

        # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø—Ä–æ—Å—ã
        self.requests[user_id] = [
            req_time
            for req_time in user_requests
            if now - req_time < self.window_seconds
        ]

        if len(self.requests[user_id]) >= self.max_requests:
            return False

        self.requests[user_id].append(now)
        return True

    def get_remaining_requests(self, user_id: int) -> int:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –∑–∞–ø—Ä–æ—Å–æ–≤"""
        return max(0, self.max_requests - len(self.requests.get(user_id, [])))


# –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π rate limiter –¥–ª—è /search (1 –∑–∞–ø—Ä–æ—Å/—Å–µ–∫—É–Ω–¥–∞)
class SearchRateLimiter:
    """Rate limiter –¥–ª—è –∫–æ–º–∞–Ω–¥—ã /search (1 –∑–∞–ø—Ä–æ—Å –≤ —Å–µ–∫—É–Ω–¥—É –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)"""

    def __init__(self):
        self.last_request: dict[int, float] = {}

    def is_allowed(self, user_id: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Ä–∞–∑—Ä–µ—à–µ–Ω –ª–∏ search –∑–∞–ø—Ä–æ—Å –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        now = time.time()
        last_time = self.last_request.get(user_id, 0)

        if now - last_time < 1.0:  # 1 —Å–µ–∫—É–Ω–¥–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
            return False

        self.last_request[user_id] = now
        return True

    def get_next_allowed_time(self, user_id: int) -> float:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤—Ä–µ–º—è –∫–æ–≥–¥–∞ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–π –∑–∞–ø—Ä–æ—Å"""
        last_time = self.last_request.get(user_id, 0)
        return max(0, 1.0 - (time.time() - last_time))


# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ rate limiters
rate_limiter = RateLimiter()
search_rate_limiter = SearchRateLimiter()


# –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –∫–æ–º–∞–Ω–¥ –±–æ—Ç–∞ —Å rate limiting
def validate_and_log_bot(require_key: bool = True):
    """
    –î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ API –∫–ª—é—á–∞, rate limiting –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    """

    def decorator(func):
        @wraps(func)
        async def wrapper(message: Message, *args, **kwargs):
            user_id = message.from_user.id
            username = message.from_user.username or "unknown"
            endpoint = get_command_endpoint(message.text or "")

            # Rate limiting –ø—Ä–æ–≤–µ—Ä–∫–∞
            if not rate_limiter.is_allowed(user_id):
                remaining = rate_limiter.get_remaining_requests(user_id)
                await message.answer(
                    f"‚è±Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ ({config.security.max_requests_per_minute}/–º–∏–Ω).\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É. –û—Å—Ç–∞–ª–æ—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤: {remaining}"
                )
                logger.warning(
                    f"Rate limit exceeded for user {user_id} (@{username}) on endpoint '{endpoint}'"
                )
                return

            # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è /search
            if endpoint == "search" and not search_rate_limiter.is_allowed(user_id):
                wait_time = search_rate_limiter.get_next_allowed_time(user_id)
                await message.answer(
                    f"‚è±Ô∏è –ü–æ–∏—Å–∫ –¥–æ—Å—Ç—É–ø–µ–Ω —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É.\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —á–µ—Ä–µ–∑ {wait_time:.1f} —Å–µ–∫—É–Ω–¥."
                )
                logger.warning(
                    f"Search rate limit exceeded for user {user_id} (@{username})"
                )
                return

            # –ü–æ–ª—É—á–∞–µ–º API –∫–ª—é—á –µ—Å–ª–∏ –Ω—É–∂–µ–Ω
            api_key = (
                await get_api_key(user_id) if require_key or not DEV_MODE else None
            )

            if require_key and not DEV_MODE:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ API –∫–ª—é—á–∞
                if not api_key:
                    await message.answer(
                        f"üîë –°–Ω–∞—á–∞–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏ API –∫–ª—é—á:\n{hcode('/key YOUR_API_KEY')}"
                    )
                    logger.info(
                        f"User {user_id} (@{username}) attempted to use {endpoint} without API key"
                    )
                    return

                # –í–∞–ª–∏–¥–∏—Ä—É–µ–º –∫–ª—é—á —á–µ—Ä–µ–∑ Billing Service
                if not await api_client.validate_key(api_key, endpoint):
                    await message.answer(
                        "‚ùå API –∫–ª—é—á –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –∏–ª–∏ –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç.\n"
                        "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–ª—é—á –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                    )
                    logger.warning(
                        f"Invalid/expired API key used by user {user_id} (@{username}) for endpoint '{endpoint}'"
                    )
                    return

            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞—á–∞–ª–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã
            logger.info(
                f"Processing {endpoint} command for user {user_id} (@{username})"
            )

            command_label = endpoint or "unknown"
            start_time = time.perf_counter()
            BOT_COMMANDS_TOTAL.labels(command=command_label).inc()
            BOT_LAST_ACTIVITY.set_to_current_time()

            # –í—ã–ø–æ–ª–Ω—è–µ–º –æ—Å–Ω–æ–≤–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
            try:
                result = await func(message, *args, **kwargs)
                logger.debug(f"Successfully processed {endpoint} for user {user_id}")
            except Exception as e:
                BOT_COMMAND_ERRORS_TOTAL.labels(command=command_label).inc()
                logger.error(
                    f"Error processing {endpoint} for user {user_id}: {type(e).__name__}"
                )
                raise
            finally:
                duration = time.perf_counter() - start_time
                if duration < 0:
                    duration = 0.0
                BOT_COMMAND_DURATION_SECONDS.labels(command=command_label).observe(
                    duration
                )

            # –õ–æ–≥–∏—Ä—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ (–µ—Å–ª–∏ –µ—Å—Ç—å –∫–ª—é—á –∏ –Ω–µ dev —Ä–µ–∂–∏–º)
            if not DEV_MODE and api_key:
                try:
                    await api_client.log_usage(api_key, endpoint)
                    logger.debug(
                        f"Usage logged for endpoint '{endpoint}' by user {user_id}"
                    )
                except Exception as e:
                    logger.error(
                        f"Failed to log usage for endpoint '{endpoint}': {type(e).__name__}"
                    )

            return result

        return wrapper

    return decorator


@dp.message(CommandStart())
@validate_and_log_bot(require_key=False)
async def command_start_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start
    """
    user_id = message.from_user.id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ API –∫–ª—é—á–∞
    api_key = await get_api_key(user_id)

    if not api_key:
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π API –∫–ª—é—á —á–µ—Ä–µ–∑ Billing Service
        if not DEV_MODE:
            try:
                new_api_key = await api_client.create_billing_key(
                    tg_id=user_id,
                    email=None,  # email –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
                )
                if new_api_key:
                    await save_api_key(user_id, new_api_key)
                    api_key = new_api_key
                    logger.info(f"Successfully created new API key for user {user_id}")
            except Exception as e:
                logger.error(
                    f"Failed to create API key for user {user_id}: {type(e).__name__}"
                )

        if not api_key:
            await message.answer(
                f"üëã –ü—Ä–∏–≤–µ—Ç, {hbold(message.from_user.full_name)}!\n\n"
                "üîë –î–ª—è —Ä–∞–±–æ—Ç—ã —Å ZakupAI –Ω—É–∂–µ–Ω API –∫–ª—é—á.\n"
                f"–û—Ç–ø—Ä–∞–≤—å –º–Ω–µ –∫–æ–º–∞–Ω–¥—É: {hcode('/key YOUR_API_KEY')}\n\n"
                "–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—ã:\n"
                f"‚Ä¢ {hcode('/search')} &lt;–∑–∞–ø—Ä–æ—Å&gt; - –ø–æ–∏—Å–∫ –ª–æ—Ç–æ–≤\n"
                f"‚Ä¢ {hcode('/lot <id|url>')} - –∞–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞\n"
                f"‚Ä¢ {hcode('/help')} - —Å–ø—Ä–∞–≤–∫–∞"
            )
        else:
            await message.answer(
                f"üëã –ü—Ä–∏–≤–µ—Ç, {hbold(message.from_user.full_name)}!\n\n"
                "‚úÖ API –∫–ª—é—á —Å–æ–∑–¥–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!\n\n"
                "üöÄ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                f"‚Ä¢ {hcode('/search')} &lt;–∑–∞–ø—Ä–æ—Å&gt; - –ø–æ–∏—Å–∫ –ª–æ—Ç–æ–≤\n"
                f"‚Ä¢ {hcode('/lot <id|url>')} - –∞–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞\n"
                f"‚Ä¢ {hcode('/help')} - —Å–ø—Ä–∞–≤–∫–∞"
            )
    else:
        # –í–∞–ª–∏–¥–∏—Ä—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–ª—é—á
        if not DEV_MODE and not await api_client.validate_key(api_key, "start"):
            await message.answer(
                f"‚ö†Ô∏è –í–∞—à API –∫–ª—é—á –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –∏–ª–∏ –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç.\n\n"
                f"–û–±–Ω–æ–≤–∏—Ç–µ –∫–ª—é—á: {hcode('/key YOUR_NEW_API_KEY')}"
            )
        else:
            await message.answer(
                f"‚úÖ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω–æ, {hbold(message.from_user.full_name)}!\n\n"
                "üöÄ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
                f"‚Ä¢ {hcode('/search')} &lt;–∑–∞–ø—Ä–æ—Å&gt; - –ø–æ–∏—Å–∫ –ª–æ—Ç–æ–≤\n"
                f"‚Ä¢ {hcode('/lot <id|url>')} - –∞–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞\n"
                f"‚Ä¢ {hcode('/key <–Ω–æ–≤—ã–π_–∫–ª—é—á>')} - –æ–±–Ω–æ–≤–∏—Ç—å API –∫–ª—é—á\n"
                f"‚Ä¢ {hcode('/help')} - —Å–ø—Ä–∞–≤–∫–∞"
            )


@dp.message(Command("key"))
@validate_and_log_bot(require_key=False)
async def command_key_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /key –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è API –∫–ª—é—á–∞
    """
    user_id = message.from_user.id

    # –ò–∑–≤–ª–µ–∫–∞–µ–º API –∫–ª—é—á –∏–∑ –∫–æ–º–∞–Ω–¥—ã
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer(
            f"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã.\n–ò—Å–ø–æ–ª—å–∑—É–π: {hcode('/key YOUR_API_KEY')}"
        )
        return

    api_key = args[1].strip()

    if len(api_key) < 10:  # –ë–∞–∑–æ–≤–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è
        await message.answer("‚ùå API –∫–ª—é—á —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π")
        return

    try:
        if DEV_MODE:
            await save_api_key(user_id, api_key)
            await message.answer("‚úÖ API –∫–ª—é—á —Å–æ—Ö—Ä–∞–Ω—ë–Ω (dev —Ä–µ–∂–∏–º)")
        else:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –∫–ª—é—á–∞ —á–µ—Ä–µ–∑ Billing Service
            if await api_client.validate_key(api_key, "key"):
                await save_api_key(user_id, api_key)
                await message.answer("‚úÖ API –∫–ª—é—á —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∏ –ø—Ä–æ–≤–µ—Ä–µ–Ω!")
                # –õ–æ–≥–∏—Ä—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –¥–ª—è –∫–æ–º–∞–Ω–¥—ã key
                await api_client.log_usage(api_key, "key")
            else:
                await message.answer(
                    "‚ùå API –∫–ª—é—á –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –∏–ª–∏ –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç.\n"
                    "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–ª—é—á –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
                )

    except Exception as e:
        logger.error(f"Failed to save API key for user {user_id}: {type(e).__name__}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è API –∫–ª—é—á–∞")


@dp.message(Command("search"))
@validate_and_log_bot(require_key=True)
async def command_search_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /search –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ª–æ—Ç–æ–≤

    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:
    - min_amount:X - –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ª–æ—Ç–∞
    - max_amount:X - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ª–æ—Ç–∞
    - status:X - —Å—Ç–∞—Ç—É—Å –ª–æ—Ç–∞ (1-10)
    """
    user_id = message.from_user.id
    username = message.from_user.username or "unknown"

    logger.info(f"Processing advanced search command for user {user_id} (@{username})")

    # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer(
            "üîç –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:\n"
            f"{hcode('/search <–∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞> [–ø–∞—Ä–∞–º–µ—Ç—Ä—ã]')}\n\n"
            "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏:\n"
            f"‚Ä¢ {hcode('min_amount:1000')} - –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞\n"
            f"‚Ä¢ {hcode('max_amount:50000')} - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞\n"
            f"‚Ä¢ {hcode('status:1')} - —Å—Ç–∞—Ç—É—Å –ª–æ—Ç–∞ (1-10)\n\n"
            "–ü—Ä–∏–º–µ—Ä—ã:\n"
            f"‚Ä¢ {hcode('/search –∫–æ–º–ø—å—é—Ç–µ—Ä—ã min_amount:10000')}\n"
            f"‚Ä¢ {hcode('/search —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ max_amount:1000000 status:1')}\n"
            f"‚Ä¢ {hcode('/search –º–µ–¥–∏—Ü–∏–Ω—Å–∫–æ–µ –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ min_amount:5000 max_amount:100000')}"
        )
        return

    search_text = args[1].strip()

    # –ü–∞—Ä—Å–∏–Ω–≥ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ø–æ–∏—Å–∫–∞ —Å –ø–æ–º–æ—â—å—é —Ä–µ–≥—É–ª—è—Ä–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π
    import re

    # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    params = {}
    param_patterns = {
        "min_amount": r"min_amount:(\d+(?:\.\d+)?)",
        "max_amount": r"max_amount:(\d+(?:\.\d+)?)",
        "status": r"status:(\d+)",
    }

    query_text = search_text

    for param_name, pattern in param_patterns.items():
        match = re.search(pattern, search_text, re.IGNORECASE)
        if match:
            params[param_name] = match.group(1)
            # –£–¥–∞–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä –∏–∑ —Ç–µ–∫—Å—Ç–∞ –∑–∞–ø—Ä–æ—Å–∞
            query_text = re.sub(pattern, "", query_text, flags=re.IGNORECASE).strip()

    # –û—á–∏—â–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã –≤ –∑–∞–ø—Ä–æ—Å–µ
    query_text = " ".join(query_text.split())

    # –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–ø—Ä–æ—Å–∞
    if len(query_text) < 2:
        await message.answer("‚ùå –ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π (–º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞)")
        return

    if len(query_text) > 200:
        await message.answer(
            "‚ùå –ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π (–º–∞–∫—Å–∏–º—É–º 200 —Å–∏–º–≤–æ–ª–æ–≤)"
        )
        return

    # –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    try:
        if "min_amount" in params:
            min_amount = float(params["min_amount"])
            if min_amount < 0:
                await message.answer("‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–π")
                return
        else:
            min_amount = None

        if "max_amount" in params:
            max_amount = float(params["max_amount"])
            if max_amount < 0:
                await message.answer(
                    "‚ùå –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–π"
                )
                return
        else:
            max_amount = None

        if (
            min_amount is not None
            and max_amount is not None
            and max_amount < min_amount
        ):
            await message.answer(
                "‚ùå –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π"
            )
            return

        if "status" in params:
            status = int(params["status"])
            if status not in range(1, 11):
                await message.answer("‚ùå –°—Ç–∞—Ç—É—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 1 –¥–æ 10")
                return
        else:
            status = None

    except ValueError:
        await message.answer(
            "‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å."
        )
        return

    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–æ–∏—Å–∫–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
    filters_text = []
    if min_amount is not None:
        filters_text.append(f"–æ—Ç {min_amount:,.0f} —Ç–µ–Ω–≥–µ")
    if max_amount is not None:
        filters_text.append(f"–¥–æ {max_amount:,.0f} —Ç–µ–Ω–≥–µ")
    if status is not None:
        filters_text.append(f"—Å—Ç–∞—Ç—É—Å {status}")

    loading_text = "üîç –ò—â—É –ª–æ—Ç—ã"
    if filters_text:
        loading_text += f" ({', '.join(filters_text)})"
    loading_text += "... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥"

    loading_message = await message.answer(loading_text)

    try:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ –Ω–æ–≤—ã–µ Web API —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã

        import aiohttp

        # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å –∫ –Ω–∞—à–µ–º—É —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–º—É –ø–æ–∏—Å–∫—É
        search_payload = {"query": query_text, "limit": 10, "offset": 0}

        if min_amount is not None:
            search_payload["min_amount"] = min_amount
        if max_amount is not None:
            search_payload["max_amount"] = max_amount
        if status is not None:
            search_payload["status"] = str(status)

        # –í—ã–∑—ã–≤–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π Web API
        web_url = (
            config.web.base_url
            if hasattr(config.web, "base_url")
            else "http://localhost:8000"
        )

        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{web_url}/api/search/advanced",
                json=search_payload,
                timeout=aiohttp.ClientTimeout(total=30),
            ) as resp:
                if resp.status == 200:
                    search_results = await resp.json()
                    results_text = format_advanced_search_results(
                        search_results, query_text, filters_text
                    )

                    # Add Web UI CTA
                    web_url = getattr(config.web, "base_url", "http://localhost:8000")
                    if search_results.get("total_count", 0) > 3:
                        results_text += f"\n\n‚ÑπÔ∏è –ü–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ –≤ Web UI: {web_url}/search?q={query_text.replace(' ', '+')}"
                else:
                    error_text = await resp.text()
                    logger.error(
                        f"Advanced search API error: {resp.status} - {error_text}"
                    )

                    # Fallback to old search method
                    from services_v2 import search_lots_for_telegram_v2

                    results_text = await search_lots_for_telegram_v2(
                        query_text, limit=10, show_source=True, user_id=user_id
                    )

        # –£–¥–∞–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏
        await loading_message.delete()

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        await message.answer(
            results_text, parse_mode="HTML", disable_web_page_preview=True
        )

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–∏—Å–∫–∞ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
        user_search_sessions[user_id] = {
            "query": query_text,
            "params": params,
            "offset": 10,  # –°–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 10-–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
            "limit": 10,
            "timestamp": message.date.timestamp(),
        }

        logger.info(
            f"Advanced search completed for user {user_id} (@{username}) with query '{query_text}' and params {params}"
        )

    except Exception as e:
        await loading_message.delete()
        await message.answer(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞: {type(e).__name__}")
        logger.error(
            f"Error in advanced search for '{query_text}' by user {user_id}: {type(e).__name__}: {str(e)}"
        )


@dp.message(Command("search_continue"))
@validate_and_log_bot(require_key=True)
async def command_search_continue_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /search_continue –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞ –ª–æ—Ç–æ–≤
    """
    user_id = message.from_user.id
    username = message.from_user.username or "unknown"

    logger.info(f"Processing search_continue command for user {user_id} (@{username})")

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if user_id not in user_search_sessions:
        await message.answer(
            "‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è.\n\n"
            "–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /search"
        )
        return

    search_session = user_search_sessions[user_id]

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∏—Å—Ç–µ–∫ –ª–∏ –ø–æ–∏—Å–∫ (15 –º–∏–Ω—É—Ç)
    import time

    if time.time() - search_session["timestamp"] > 900:  # 15 –º–∏–Ω—É—Ç
        del user_search_sessions[user_id]
        await message.answer(
            "‚è∞ –°–µ—Å—Å–∏—è –ø–æ–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–ª–∞.\n\n"
            "–í—ã–ø–æ–ª–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫ —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /search"
        )
        return

    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–æ–∏—Å–∫–∞
    loading_message = await message.answer("üîç –ó–∞–≥—Ä—É–∂–∞—é —Å–ª–µ–¥—É—é—â–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã...")

    try:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞
        query = search_session["query"]
        offset = search_session["offset"]
        limit = search_session["limit"]

        # –í—ã–ø–æ–ª–Ω—è–µ–º –ø–æ–∏—Å–∫ —Å–æ —Å–º–µ—â–µ–Ω–∏–µ–º
        from services_v2 import search_lots_for_telegram_v2

        results_text = await search_lots_for_telegram_v2(
            query, limit=limit, offset=offset, show_source=True, user_id=user_id
        )

        # –£–¥–∞–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏
        await loading_message.delete()

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        await message.answer(
            results_text, parse_mode="HTML", disable_web_page_preview=True
        )

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        search_session["offset"] += limit
        search_session["timestamp"] = message.date.timestamp()

        logger.info(
            f"Search continue completed for user {user_id} (@{username}) with query '{query}', offset {offset}"
        )

    except Exception as e:
        await loading_message.delete()
        await message.answer(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –ø–æ–∏—Å–∫–∞: {type(e).__name__}")
        logger.error(f"Search continue failed for user {user_id}: {e}")


@dp.message(Command("lot"))
@validate_and_log_bot(require_key=True)
async def command_lot_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /lot –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞
    """
    user_id = message.from_user.id

    # –ò–∑–≤–ª–µ–∫–∞–µ–º ID –ª–æ—Ç–∞
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer(
            f"‚ùå –£–∫–∞–∂–∏ ID –∏–ª–∏ URL –ª–æ—Ç–∞.\n–ü—Ä–∏–º–µ—Ä: {hcode('/lot 12345')}"
        )
        return

    lot_input = args[1].strip()

    # –ò–∑–≤–ª–µ–∫–∞–µ–º ID –∏–∑ URL –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    lot_id = extract_lot_id(lot_input)
    if not lot_id:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å ID –ª–æ—Ç–∞")
        return

    if DEV_MODE:
        await message.answer("üîÑ Dev —Ä–µ–∂–∏–º: —ç–º—É–ª—è—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞...")
        # –≠–º—É–ª—è—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤ dev —Ä–µ–∂–∏–º–µ
        dev_result = {
            "lot_id": lot_id,
            "tldr": {
                "title": f"–¢–µ—Å—Ç–æ–≤—ã–π –ª–æ—Ç {lot_id}",
                "price": "1000000",
                "customer": "–¢–µ—Å—Ç–æ–≤—ã–π –∑–∞–∫–∞–∑—á–∏–∫",
            },
            "risk": {"score": 0.3, "explanation": "–°—Ä–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞ (dev)"},
            "finance": {
                "amount_without_vat": "892857",
                "vat_amount": "107143",
                "total_with_vat": "1000000",
            },
        }
        formatted_result = format_lot_analysis(dev_result)
        await message.answer(formatted_result)
    else:
        await message.answer("üîÑ –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –ª–æ—Ç...")

        try:
            # –ü–æ–ª—É—á–∞–µ–º API –∫–ª—é—á (—É–∂–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä–æ–º)
            api_key = await get_api_key(user_id)

            # –°–æ–∑–¥–∞—ë–º –∫–ª–∏–µ–Ω—Ç —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º API –∫–ª—é—á–æ–º
            user_client = ZakupaiAPIClient(
                base_url=config.api.zakupai_base_url,
                api_key=api_key,
            )

            # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞
            result = await analyze_lot_pipeline(user_client, lot_id)

            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            formatted_result = format_lot_analysis(result)
            await message.answer(formatted_result)

        except Exception as e:
            logger.error(
                f"Failed to analyze lot {lot_id} for user {user_id}: {type(e).__name__}"
            )
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞")


@dp.message(Command("rnu"))
@validate_and_log_bot(require_key=True)
async def command_rnu_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /rnu –¥–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏ BIN —á–µ—Ä–µ–∑ RNU
    –§–æ—Ä–º–∞—Ç: /rnu 123456789012
    """
    user_id = message.from_user.id
    args = message.text.split(maxsplit=1)

    if len(args) < 2:
        await message.answer(
            f"‚ùå –£–∫–∞–∂–∏—Ç–µ BIN –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞.\n–ü—Ä–∏–º–µ—Ä: {hcode('/rnu 123456789012')}"
        )
        return

    supplier_bin = args[1].strip()

    # Validate BIN format
    if not supplier_bin.isdigit() or len(supplier_bin) != 12:
        await message.answer("‚ùå BIN –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ä–æ–≤–Ω–æ 12 —Ü–∏—Ñ—Ä")
        return

    try:
        # Get RNU validation via API
        async with httpx.AsyncClient(timeout=10) as client:
            response = await client.get(
                f"{config.api.zakupai_base_url}/risk/validate_rnu/{supplier_bin}"
            )

            if response.status_code == 200:
                rnu_data = response.json()
                status = rnu_data.get("status", "UNKNOWN")

                # Status emoji mapping
                status_emoji = {
                    "ACTIVE": "üü¢",
                    "BLOCKED": "üî¥",
                    "SUSPENDED": "üü°",
                    "LIQUIDATED": "‚ö´",
                    "BLACKLISTED": "üö´",
                    "UNKNOWN": "‚ùì",
                }

                emoji = status_emoji.get(status, "‚ö†Ô∏è")
                web_url = getattr(config.web, "base_url", "http://localhost:8000")

                # Short response with CTA
                response_text = f"BIN {supplier_bin}: {emoji} {status}.\n‚ÑπÔ∏è –ü–æ–¥—Ä–æ–±–Ω–µ–µ –≤ Web UI: {web_url}/rnu/{supplier_bin}"

                await message.answer(response_text, disable_web_page_preview=True)
            else:
                await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ BIN {supplier_bin}")

    except Exception as e:
        logger.error(f"RNU command error for user {user_id}: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ RNU")


@dp.message(Command("supplier"))
@validate_and_log_bot(require_key=True)
async def command_supplier_handler(message: Message) -> None:
    """
    Week 4.2: Enhanced supplier search with modular sources
    –§–æ—Ä–º–∞—Ç: /supplier –º–µ–±–µ–ª—å [region=KZ] [sources=satu,1688]
    """
    user_id = message.from_user.id
    args = message.text.split()

    if len(args) < 2:
        await message.answer(
            f"‚ùå –£–∫–∞–∂–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞/—É—Å–ª—É–≥–∏.\n"
            f"–ü—Ä–∏–º–µ—Ä: {hcode('/supplier –º–µ–±–µ–ª—å')}\n"
            f"–° —Ñ–∏–ª—å—Ç—Ä–∞–º–∏: {hcode('/supplier –º–µ–±–µ–ª—å region=KZ sources=satu,1688')}"
        )
        return

    lot_name = args[1].strip()

    # Parse optional parameters
    params = {}
    for arg in args[2:]:
        if "=" in arg:
            key, value = arg.split("=", 1)
            if key == "sources":
                params["sources"] = value
            elif key == "region":
                params["region"] = value

    if len(lot_name) < 3:
        await message.answer("‚ùå –ù–∞–∑–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 3 —Å–∏–º–≤–æ–ª–∞")
        return

    try:
        # Search suppliers via Web API with enhanced parameters
        async with httpx.AsyncClient(timeout=15) as client:
            response = await client.get(
                f"{config.api.zakupai_base_url}/api/supplier/{lot_name}", params=params
            )

            if response.status_code == 200:
                supplier_data = response.json()
                suppliers = supplier_data.get("suppliers", [])
                sources_used = supplier_data.get("sources_used", [])
                cache_hit = supplier_data.get("cache_hit", False)

                if suppliers:
                    count = len(suppliers)
                    web_url = getattr(config.web, "base_url", "http://localhost:8000")

                    # Show top 3 suppliers with source info
                    top_suppliers = []
                    for i, supplier in enumerate(suppliers[:3], 1):
                        rating = supplier.get("rating", 0)
                        stars = "‚≠ê" * min(int(rating), 5)
                        region_flag = {"KZ": "üá∞üáø", "CN": "üá®üá≥", "RU": "üá∑üá∫"}.get(
                            supplier.get("region", ""), ""
                        )
                        source = supplier.get("source", "Unknown")
                        top_suppliers.append(
                            f"{i}. {supplier['name']} {stars}\n"
                            f"   {region_flag} {source} | {supplier.get('budget', 0):,.0f} ‚Ç∏"
                        )

                    cache_status = "‚ö° (cache)" if cache_hit else "üîç (search)"
                    sources_text = ", ".join(sources_used) if sources_used else "All"

                    response_text = (
                        f"–ù–∞–π–¥–µ–Ω–æ {count} –ø–æ—Å—Ç–∞–≤—â–∏–∫–æ–≤ {cache_status}\n"
                        f"–ò—Å—Ç–æ—á–Ω–∏–∫–∏: {sources_text}\n\n" + "\n".join(top_suppliers)
                    )
                    response_text += f"\n\n[Web UI link]({web_url}/supplier/{lot_name})"
                else:
                    response_text = f"‚ùå –ü–æ—Å—Ç–∞–≤—â–∏–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–ª—è '{lot_name}'"

                await message.answer(
                    response_text, parse_mode="Markdown", disable_web_page_preview=True
                )
            else:
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –ø–æ—Å—Ç–∞–≤—â–∏–∫–æ–≤")

    except Exception as e:
        logger.error(f"Supplier command error for user {user_id}: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ –ø–æ–∏—Å–∫–∞ –ø–æ—Å—Ç–∞–≤—â–∏–∫–æ–≤")


@dp.message(Command("complaint"))
@validate_and_log_bot(require_key=True)
async def command_complaint_handler(message: Message) -> None:
    """
    Week 4.2: Enhanced complaint generation with PDF/Word export
    –§–æ—Ä–º–∞—Ç: /complaint 12345 –∑–∞–≤—ã—à–µ–Ω–Ω–∞—è —Ü–µ–Ω–∞ [date=2025-01-15]
    """
    user_id = message.from_user.id
    parts = message.text.split()

    if len(parts) < 3:
        await message.answer(
            f"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.\n"
            f"–ü—Ä–∏–º–µ—Ä: {hcode('/complaint 12345 –∑–∞–≤—ã—à–µ–Ω–Ω–∞—è —Ü–µ–Ω–∞')}\n"
            f"–° –¥–∞—Ç–æ–π: {hcode('/complaint 12345 –∑–∞–≤—ã—à–µ–Ω–Ω–∞—è —Ü–µ–Ω–∞ date=2025-01-15')}"
        )
        return

    try:
        lot_id = int(parts[1])
        reason_parts = []
        complaint_date = None

        # Parse reason and optional date parameter
        for part in parts[2:]:
            if part.startswith("date="):
                complaint_date = part.split("=", 1)[1]
            else:
                reason_parts.append(part)

        reason = " ".join(reason_parts).strip()

    except ValueError:
        await message.answer("‚ùå ID –ª–æ—Ç–∞ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —á–∏—Å–ª–æ–º")
        return

    if len(reason) < 5 or len(reason) > 200:
        await message.answer("‚ùå –£–∫–∞–∂–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –∂–∞–ª–æ–±—ã (5-200 —Å–∏–º–≤–æ–ª–æ–≤)")
        return

    try:
        # Generate complaint via Web API
        complaint_payload = {"reason": reason}
        if complaint_date:
            complaint_payload["date"] = complaint_date

        async with httpx.AsyncClient(timeout=20) as client:
            response = await client.post(
                f"{config.api.zakupai_base_url}/api/complaint/{lot_id}",
                json=complaint_payload,
            )

            if response.status_code == 200:
                complaint_data = response.json()
                source = complaint_data.get("source", "unknown")
                web_url = getattr(config.web, "base_url", "http://localhost:8000")

                source_icon = {"flowise": "ü§ñ", "fallback": "üìù", "cache": "‚ö°"}.get(
                    source, "üìÑ"
                )

                response_text = (
                    f"‚úÖ –ñ–∞–ª–æ–±–∞ —Å–æ–∑–¥–∞–Ω–∞ –¥–ª—è –ª–æ—Ç–∞ {lot_id} {source_icon}\n"
                    f"–ò—Å—Ç–æ—á–Ω–∏–∫: {source}\n"
                    f"–ü—Ä–∏—á–∏–Ω–∞: {reason}\n\n"
                    f"üìÑ [PDF]({web_url}/api/complaint/{lot_id}/pdf?reason={reason}&date={complaint_data.get('date', '')})\n"
                    f"üìù [Word]({web_url}/api/complaint/{lot_id}/word?reason={reason}&date={complaint_data.get('date', '')})\n\n"
                    f"[Web UI link]({web_url}/complaint/{lot_id})"
                )

                await message.answer(
                    response_text, parse_mode="Markdown", disable_web_page_preview=True
                )
            else:
                await message.answer(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∂–∞–ª–æ–±—ã –¥–ª—è –ª–æ—Ç–∞ {lot_id}")

    except Exception as e:
        logger.error(f"Complaint command error for user {user_id}: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ –∂–∞–ª–æ–±")


@dp.message(Command("subscribe"))
@validate_and_log_bot(require_key=True)
async def command_subscribe_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /subscribe –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è RNU
    –§–æ—Ä–º–∞—Ç: /subscribe 123456789012
    """
    user_id = message.from_user.id
    args = message.text.split(maxsplit=1)

    if len(args) < 2:
        await message.answer(
            f"‚ùå –£–∫–∞–∂–∏—Ç–µ BIN –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞.\n–ü—Ä–∏–º–µ—Ä: {hcode('/subscribe 123456789012')}"
        )
        return

    supplier_bin = args[1].strip()

    # Validate BIN format
    if not supplier_bin.isdigit() or len(supplier_bin) != 12:
        await message.answer("‚ùå BIN –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ä–æ–≤–Ω–æ 12 —Ü–∏—Ñ—Ä")
        return

    try:
        # Subscribe via API
        async with httpx.AsyncClient(timeout=10) as client:
            response = await client.post(
                f"{config.api.zakupai_base_url}/risk/rnu/subscribe",
                json={"supplier_bin": supplier_bin, "telegram_user_id": user_id},
            )

            if response.status_code == 200:
                await message.answer(f"‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ BIN {supplier_bin} –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!")
            elif response.status_code == 400:
                await message.answer("‚ùå –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –ø–æ–¥–ø–∏—Å–æ–∫ (–º–∞–∫—Å–∏–º—É–º 100)")
            else:
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏")

    except Exception as e:
        logger.error(f"Subscribe command error for user {user_id}: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ –ø–æ–¥–ø–∏—Å–æ–∫")


@dp.message(Command("help"))
@validate_and_log_bot(require_key=False)
async def command_help_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /help
    """
    help_text = (
        "ü§ñ ZakupAI Telegram Bot\n\n"
        "üìã –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        f"‚Ä¢ {hcode('/search')} &lt;–∑–∞–ø—Ä–æ—Å&gt; - –ø–æ–∏—Å–∫ –ª–æ—Ç–æ–≤\n"
        f"‚Ä¢ {hcode('/lot <id>')} - –∞–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞\n"
        f"‚Ä¢ {hcode('/rnu <BIN>')} - –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞\n"
        f"‚Ä¢ {hcode('/supplier <—Ç–æ–≤–∞—Ä>')} - –ø–æ–∏—Å–∫ –ø–æ—Å—Ç–∞–≤—â–∏–∫–æ–≤\n"
        f"‚Ä¢ {hcode('/complaint <lot_id> <–ø—Ä–∏—á–∏–Ω–∞>')} - —Å–æ–∑–¥–∞—Ç—å –∂–∞–ª–æ–±—É\n"
        f"‚Ä¢ {hcode('/subscribe <BIN>')} - –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è\n\n"
        "üîç –ü—Ä–∏–º–µ—Ä—ã:\n"
        f"{hcode('/search –∫–æ–º–ø—å—é—Ç–µ—Ä—ã')}\n"
        f"{hcode('/rnu 123456789012')}\n"
        f"{hcode('/supplier –æ—Ñ–∏—Å–Ω–∞—è –º–µ–±–µ–ª—å')}\n\n"
        "‚ÑπÔ∏è –ü–æ–ª–Ω—ã–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –≤ Web UI\n"
        "üîß –ü–æ–¥–¥–µ—Ä–∂–∫–∞: @zakupai_support"
    )
    await message.answer(help_text)


# =============================================================================
# Week 4.1: New Telegram Bot Commands
# =============================================================================


@dp.message(Command("import_status"))
@validate_and_log_bot(require_key=True)
async def command_import_status_handler(message: Message) -> None:
    """
    Check CSV import status by log ID
    Week 4.1: /import_status <log_id> ‚Üí short status + Web UI link
    """
    args = message.text.split()[1:] if message.text else []

    if not args:
        await message.answer(
            "Usage: /import_status <log_id>\nExample: /import_status 123"
        )
        return

    try:
        log_id = int(args[0])
    except ValueError:
        await message.answer("‚ùå Invalid log ID. Must be a number.")
        return

    try:
        async with httpx.AsyncClient(timeout=10) as client:
            response = await client.get(
                f"{config.api.zakupai_base_url}/web-ui/import-status/{log_id}"
            )

            if response.status_code == 404:
                await message.answer(f"‚ùå Import log {log_id} not found.")
                return

            if response.status_code != 200:
                await message.answer(f"‚ùå API error: {response.status_code}")
                return

            data = response.json()
            status = data["status"]
            success_rows = data["success_rows"]
            error_rows = data["error_rows"]

            # Status emoji mapping
            status_emoji = {
                "SUCCESS": "‚úÖ",
                "PARTIAL": "‚ö†Ô∏è",
                "FAILED": "‚ùå",
                "PROCESSING": "‚è≥",
            }

            emoji = status_emoji.get(status, "‚ùì")

            # Short response (‚â§1 line) + CTA
            web_url = config.api.zakupai_base_url.replace(":8000", "").replace(
                "http://", "http://"
            )

            response_text = f"{emoji} Import {log_id}: {status}. Rows OK: {success_rows}, Errors: {error_rows}"
            if error_rows > 0:
                response_text += f"\n‚ÑπÔ∏è Details: {web_url}/import/{log_id}"

            await message.answer(response_text)

    except Exception as e:
        logger.error(
            "Import status check failed", user_id=message.from_user.id, error=str(e)
        )
        await message.answer("‚ùå Service temporarily unavailable")


@dp.message(Command("lot"))
@validate_and_log_bot(require_key=True)
async def command_lot_tldr_handler(message: Message) -> None:
    """
    Get lot TL;DR summary
    Week 4.1: /lot <id> ‚Üí short TL;DR + Web UI link
    Enhanced from existing lot command
    """
    args = message.text.split()[1:] if message.text else []

    if not args:
        await message.answer("Usage: /lot <lot_id>\nExample: /lot 123456")
        return

    lot_id_str = args[0]
    lot_id = extract_lot_id(lot_id_str)

    if not lot_id or not lot_id.isdigit():
        await message.answer("‚ùå Invalid lot ID")
        return

    try:
        # Get TL;DR from Web UI API
        async with httpx.AsyncClient(timeout=10) as client:
            response = await client.get(
                f"{config.api.zakupai_base_url}/web-ui/lot/{lot_id}"
            )

            if response.status_code == 404:
                await message.answer(f"‚ùå Lot {lot_id} not found")
                return

            if response.status_code != 200:
                await message.answer(f"‚ùå API error: {response.status_code}")
                return

            data = response.json()
            summary = data["summary"]

            # Short response + Web UI link
            web_url = config.api.zakupai_base_url.replace(":8000", "").replace(
                "http://", "http://"
            )

            # Truncate summary to fit in 1 line (‚â§100 chars)
            short_summary = summary[:100] + "..." if len(summary) > 100 else summary

            response_text = (
                f"üìã {short_summary}\n‚ÑπÔ∏è Full analysis: {web_url}/lot/{lot_id}"
            )

            await message.answer(response_text)

    except Exception as e:
        logger.error(
            "Lot TL;DR failed",
            user_id=message.from_user.id,
            lot_id=lot_id,
            error=str(e),
        )
        await message.answer("‚ùå Service temporarily unavailable")


def extract_lot_id(lot_input: str) -> str:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç ID –ª–æ—Ç–∞ –∏–∑ —Å—Ç—Ä–æ–∫–∏ (ID –∏–ª–∏ URL)
    """
    import re

    # –ï—Å–ª–∏ —ç—Ç–æ —É–∂–µ —á–∏—Å–ª–æ
    if lot_input.isdigit():
        return lot_input

    # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–∑ URL
    url_patterns = [
        r"/announce/index/(\d+)",
        r"/lot/(\d+)",
        r"lot_id=(\d+)",
        r"id=(\d+)",
    ]

    for pattern in url_patterns:
        match = re.search(pattern, lot_input)
        if match:
            return match.group(1)

    return ""


async def analyze_lot_pipeline(client: ZakupaiAPIClient, lot_id: str) -> dict:
    """
    –ü–æ–ª–Ω—ã–π –ø–∞–π–ø–ª–∞–π–Ω –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞
    """
    result = {
        "lot_id": lot_id,
        "tldr": None,
        "risk": None,
        "finance": None,
        "error": None,
    }

    try:
        # 1. TL;DR —á–µ—Ä–µ–∑ doc-service
        tldr_data = await client.get_tldr(lot_id)
        result["tldr"] = tldr_data

        # 2. –†–∏—Å–∫-–∞–Ω–∞–ª–∏–∑
        risk_data = await client.get_risk_score(lot_id)
        result["risk"] = risk_data

        # 3. –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —Ä–∞—Å—á—ë—Ç—ã (–ø—Ä–∏–º–µ—Ä —Å –ù–î–°)
        if tldr_data and "price" in tldr_data:
            vat_data = await client.calculate_vat(tldr_data["price"])
            result["finance"] = vat_data

    except Exception as e:
        result["error"] = str(e)

    return result


def format_lot_analysis(result: dict) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
    """
    lot_id = result["lot_id"]

    if result.get("error"):
        return f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞ {lot_id}: {result['error']}"

    output = [f"üìä –ê–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞ {hbold(lot_id)}"]

    # TL;DR
    if result.get("tldr"):
        tldr = result["tldr"]
        output.append(f"\nüìù {hbold('–ö—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ:')}")
        output.append(f"‚Ä¢ –ù–∞–∑–≤–∞–Ω–∏–µ: {tldr.get('title', 'N/A')}")
        output.append(f"‚Ä¢ –¶–µ–Ω–∞: {tldr.get('price', 'N/A')} —Ç–≥")
        output.append(f"‚Ä¢ –ó–∞–∫–∞–∑—á–∏–∫: {tldr.get('customer', 'N/A')}")

    # –†–∏—Å–∫-–∞–Ω–∞–ª–∏–∑
    if result.get("risk"):
        risk = result["risk"]
        risk_score = risk.get("score", 0)
        risk_level = (
            "üü¢ –ù–∏–∑–∫–∏–π"
            if risk_score < 0.3
            else "üü° –°—Ä–µ–¥–Ω–∏–π" if risk_score < 0.7 else "üî¥ –í—ã—Å–æ–∫–∏–π"
        )

        output.append(f"\n‚ö†Ô∏è {hbold('–†–∏—Å–∫-–∞–Ω–∞–ª–∏–∑:')}")
        output.append(f"‚Ä¢ –£—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: {risk_level} ({risk_score:.2f})")
        if "explanation" in risk:
            output.append(f"‚Ä¢ –ü—Ä–∏—á–∏–Ω—ã: {risk['explanation']}")

    # –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —Ä–∞—Å—á—ë—Ç—ã
    if result.get("finance"):
        finance = result["finance"]
        output.append(f"\nüí∞ {hbold('–§–∏–Ω–∞–Ω—Å—ã:')}")
        output.append(f"‚Ä¢ –°—É–º–º–∞ –±–µ–∑ –ù–î–°: {finance.get('amount_without_vat', 'N/A')} —Ç–≥")
        output.append(f"‚Ä¢ –ù–î–° (12%): {finance.get('vat_amount', 'N/A')} —Ç–≥")
        output.append(f"‚Ä¢ –ò—Ç–æ–≥–æ —Å –ù–î–°: {finance.get('total_with_vat', 'N/A')} —Ç–≥")

    return "\n".join(output)


async def setup_webhook():
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ webhook –¥–ª—è production —Ä–µ–∂–∏–º–∞"""
    if not USE_WEBHOOK:
        return

    webhook_url = config.telegram.webhook_url
    webhook_secret = config.telegram.webhook_secret

    logger.info(f"Setting webhook to: {webhook_url}")

    # –£–¥–∞–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π webhook
    await bot.delete_webhook(drop_pending_updates=True)

    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–æ–≤—ã–π webhook
    await bot.set_webhook(
        url=webhook_url, secret_token=webhook_secret, drop_pending_updates=True
    )

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º webhook
    webhook_info = await bot.get_webhook_info()
    logger.info(f"Webhook info: {webhook_info}")


@asynccontextmanager
async def lifespan_context():
    """
    –ö–æ–Ω—Ç–µ–∫—Å—Ç –∂–∏–∑–Ω–µ–Ω–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    """
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
    await init_db()
    logger.info("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")

    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ webhook –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    if USE_WEBHOOK:
        await setup_webhook()

    yield

    # –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
    if USE_WEBHOOK:
        await bot.delete_webhook(drop_pending_updates=False)

    logger.info("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞")


async def webhook_main() -> None:
    """
    –ó–∞–ø—É—Å–∫ –≤ webhook —Ä–µ–∂–∏–º–µ
    """
    async with lifespan_context():
        app = web.Application()

        webhook_requests_handler = SimpleRequestHandler(
            dispatcher=dp,
            bot=bot,
            secret_token=config.telegram.webhook_secret,
        )
        webhook_requests_handler.register(app, path="/webhook/telegram")

        # Health check endpoint
        async def health_check(request):
            return web.Response(text="OK", status=200)

        app.router.add_get("/health", health_check)

        # Setup application and start server
        setup_application(app, dp, bot=bot)

        logger.info("üöÄ ZakupAI Telegram Bot –∑–∞–ø—É—â–µ–Ω –≤ webhook —Ä–µ–∂–∏–º–µ")

        # –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
        runner = web.AppRunner(app)
        await runner.setup()
        site = web.TCPSite(runner, host="0.0.0.0", port=8000)  # nosec B104
        await site.start()

        # –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª
        try:
            await asyncio.Future()  # run forever
        except KeyboardInterrupt:
            logger.info("–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è")
        finally:
            await runner.cleanup()


async def polling_main() -> None:
    """
    –ó–∞–ø—É—Å–∫ –≤ polling —Ä–µ–∂–∏–º–µ
    """
    async with lifespan_context():
        logger.info("üöÄ ZakupAI Telegram Bot –∑–∞–ø—É—â–µ–Ω –≤ polling —Ä–µ–∂–∏–º–µ")
        await dp.start_polling(bot)


async def main() -> None:
    """
    –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞
    """
    if USE_WEBHOOK:
        logger.info(f"–†–µ–∂–∏–º: Webhook ({config.telegram.webhook_url})")
        await webhook_main()
    else:
        logger.info("–†–µ–∂–∏–º: Polling (development)")
        await polling_main()


if __name__ == "__main__":
    asyncio.run(main())
