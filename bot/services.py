"""
–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π –º–æ–¥—É–ª—å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≤–Ω–µ—à–Ω–∏–º–∏ —Å–µ—Ä–≤–∏—Å–∞–º–∏ ZakupAI
"""

import logging
from datetime import datetime
from typing import Any

import aiohttp
from config import config
from error_handler import handle_api_error, log_security_event
from models import (
    LotAnalysisResult,
    MarginResponse,
    RiskScoreResponse,
    SearchResult,
    TLDRResponse,
    VATResponse,
)

logger = logging.getLogger(__name__)


class BillingService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∏–ª–ª–∏–Ω–≥–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π"""

    def __init__(self):
        self.base_url = config.api.billing_service_url

    async def validate_key_and_log_usage(
        self, api_key: str, user_id: int, endpoint: str, cost: int = 1
    ) -> dict[str, Any]:
        """–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–∞ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è"""

        headers = {"X-API-Key": api_key, "Content-Type": "application/json"}

        # –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–ª—é—á–∞
        validate_data = {"api_key": api_key, "endpoint": endpoint, "cost": cost}

        try:
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=config.security.request_timeout),
                connector=aiohttp.TCPConnector(ssl=config.security.ssl_verify),
            ) as session:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª—é—á –∏ –ª–∏–º–∏—Ç—ã
                async with session.post(
                    f"{self.base_url}/billing/validate_key",
                    json=validate_data,
                    headers=headers,
                ) as response:
                    if response.status == 401:
                        log_security_event(
                            "INVALID_API_KEY", user_id, {"endpoint": endpoint}
                        )
                        return {"valid": False, "error": "üîë –ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π API –∫–ª—é—á"}

                    if response.status == 429:
                        log_security_event(
                            "RATE_LIMIT_EXCEEDED", user_id, {"endpoint": endpoint}
                        )
                        return {
                            "valid": False,
                            "error": "‚è±Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ",
                        }

                    if response.status != 200:
                        logger.error(f"Billing service error: {response.status}")
                        return {"valid": False, "error": "‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ –±–∏–ª–ª–∏–Ω–≥–∞"}

                    result = await response.json()

                    if not result.get("valid", False):
                        return {
                            "valid": False,
                            "error": result.get("message", "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∫–ª—é—á–∞"),
                        }

                # –õ–æ–≥–∏—Ä—É–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
                usage_data = {
                    "api_key": api_key,
                    "user_id": user_id,
                    "endpoint": endpoint,
                    "cost": cost,
                    "timestamp": datetime.now().isoformat(),
                }

                async with session.post(
                    f"{self.base_url}/billing/usage", json=usage_data, headers=headers
                ) as response:
                    if response.status != 200:
                        logger.warning(f"Failed to log usage: {response.status}")
                        # –ù–µ –±–ª–æ–∫–∏—Ä—É–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –µ—Å–ª–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å

                return {"valid": True, "user_plan": result.get("plan", "free")}

        except TimeoutError:
            logger.error(f"Timeout validating API key for user {user_id}")
            return {"valid": False, "error": "‚è±Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è"}
        except Exception as e:
            logger.error(f"Error validating API key: {type(e).__name__}")
            return {"valid": False, "error": handle_api_error(e, "billing validation")}


class GoszakupService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å API goszakup.gov.kz"""

    def __init__(self):
        self.base_url = "https://ows.goszakup.gov.kz/v3/trd/lots"

    async def search_lots(self, query: str, limit: int = 10) -> list[dict[str, Any]]:
        """–ü–æ–∏—Å–∫ –ª–æ—Ç–æ–≤ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º"""

        params = {
            "nameRu": query,
            "limit": min(limit, 50),  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º—É–º
            "offset": 0,
        }

        headers = {"User-Agent": "ZakupAI Bot/1.0", "Accept": "application/json"}

        try:
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=30),
                connector=aiohttp.TCPConnector(ssl=True),
            ) as session:
                async with session.get(
                    self.base_url, params=params, headers=headers
                ) as response:
                    if response.status != 200:
                        logger.error(f"Goszakup API error: {response.status}")
                        return []

                    data = await response.json()
                    lots = data.get("items", [])

                    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                    formatted_lots = []
                    for lot in lots[:limit]:
                        formatted_lot = {
                            "id": str(lot.get("id", "")),
                            "name": lot.get("nameRu", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"),
                            "customer": lot.get("customer", {}).get(
                                "nameRu", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∑–∞–∫–∞–∑—á–∏–∫"
                            ),
                            "price": lot.get("estimateAmount", 0),
                            "currency": "KZT",
                            "status": lot.get("status", {}).get("nameRu", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"),
                            "deadline": lot.get("endDate", ""),
                            "url": f"https://goszakup.gov.kz/ru/announce/index/{lot.get('id', '')}",
                        }
                        formatted_lots.append(formatted_lot)

                    return formatted_lots

        except TimeoutError:
            logger.error("Timeout searching lots in goszakup")
            return []
        except Exception as e:
            logger.error(f"Error searching lots: {type(e).__name__}")
            return []


class ZakupAIService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–º–∏ API ZakupAI"""

    def __init__(self):
        self.gateway_url = config.api.zakupai_api_url

    async def get_tldr(self, lot_id: str, api_key: str) -> TLDRResponse | None:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ TL;DR –¥–ª—è –ª–æ—Ç–∞"""
        return await self._make_request(
            "/doc/tldr", {"lot_id": lot_id}, api_key, TLDRResponse
        )

    async def get_risk_score(
        self, lot_id: str, api_key: str
    ) -> RiskScoreResponse | None:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–∏—Å–∫-—Å–∫–æ—Ä–∞ –¥–ª—è –ª–æ—Ç–∞"""
        return await self._make_request(
            "/risk/score", {"lot_id": lot_id}, api_key, RiskScoreResponse
        )

    async def calculate_vat(
        self, amount: float, api_key: str, vat_rate: float = 0.12
    ) -> VATResponse | None:
        """–†–∞—Å—á–µ—Ç –ù–î–°"""
        return await self._make_request(
            "/calc/vat", {"amount": amount, "vat_rate": vat_rate}, api_key, VATResponse
        )

    async def calculate_margin(
        self, cost_price: float, selling_price: float, api_key: str, quantity: int = 1
    ) -> MarginResponse | None:
        """–†–∞—Å—á–µ—Ç –º–∞—Ä–∂–∏–Ω–∞–ª—å–Ω–æ—Å—Ç–∏"""
        return await self._make_request(
            "/calc/margin",
            {
                "cost_price": cost_price,
                "selling_price": selling_price,
                "quantity": quantity,
            },
            api_key,
            MarginResponse,
        )

    async def search_documents(
        self, query: str, api_key: str, limit: int = 5
    ) -> list[SearchResult]:
        """–ü–æ–∏—Å–∫ –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ö"""
        result = await self._make_request(
            "/embedding/search",
            {"query": query, "limit": limit, "threshold": 0.7},
            api_key,
            dict,  # SearchResponse
        )

        if result and "results" in result:
            return [SearchResult(**item) for item in result["results"]]
        return []

    async def _make_request(
        self, endpoint: str, data: dict[str, Any], api_key: str, response_model: type
    ) -> Any | None:
        """–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ API"""

        headers = {"X-API-Key": api_key, "Content-Type": "application/json"}

        try:
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=config.security.request_timeout),
                connector=aiohttp.TCPConnector(ssl=config.security.ssl_verify),
            ) as session:
                async with session.post(
                    f"{self.gateway_url}{endpoint}", json=data, headers=headers
                ) as response:
                    if response.status == 401:
                        logger.warning(f"Unauthorized request to {endpoint}")
                        return None

                    if response.status != 200:
                        logger.error(f"API error {response.status} for {endpoint}")
                        return None

                    result = await response.json()

                    if response_model is dict:
                        return result

                    try:
                        return response_model(**result)
                    except Exception as e:
                        logger.error(f"Failed to parse response: {type(e).__name__}")
                        return None

        except TimeoutError:
            logger.error(f"Timeout for {endpoint}")
            return None
        except Exception as e:
            logger.error(f"Error calling {endpoint}: {type(e).__name__}")
            return None


# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤
billing_service = BillingService()
goszakup_service = GoszakupService()
zakupai_service = ZakupAIService()


def format_search_results(lots: list[dict[str, Any]]) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –±–æ—Ç–µ"""

    if not lots:
        return "üîç –õ–æ—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –ø–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É."

    text = f"üîç –ù–∞–π–¥–µ–Ω–æ –ª–æ—Ç–æ–≤: {len(lots)}\n\n"

    for i, lot in enumerate(lots, 1):
        price_str = f"{lot['price']:,.0f} —Ç–≥" if lot["price"] > 0 else "–¶–µ–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞"

        text += f"<b>{i}. {lot['name'][:100]}</b>\n"
        text += f"üí∞ {price_str}\n"
        text += f"üè¢ {lot['customer'][:80]}\n"
        text += f"üìÖ –°—Ç–∞—Ç—É—Å: {lot['status']}\n"

        if lot["deadline"]:
            text += f"‚è∞ –î–æ: {lot['deadline'][:10]}\n"

        text += f"üîó <a href=\"{lot['url']}\">–ü–æ–¥—Ä–æ–±–Ω–µ–µ</a>\n"
        text += f"üìä –ê–Ω–∞–ª–∏–∑: /lot {lot['id']}\n\n"

        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏—è
        if len(text) > 3500:
            remaining = len(lots) - i
            if remaining > 0:
                text += f"... –∏ –µ—â–µ {remaining} –ª–æ—Ç–æ–≤\n"
            break

    text += "üí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /lot <ID> –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞"

    return text


def format_lot_analysis(analysis: LotAnalysisResult) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞"""

    text = f"üìä <b>–ê–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞ {analysis.lot_id}</b>\n\n"

    # TL;DR
    if analysis.tldr:
        text += f"üìã <b>{analysis.tldr.title or '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'}</b>\n"
        text += f"üí∞ {analysis.tldr.price:,.0f} {analysis.tldr.currency}\n"
        text += f"üè¢ {analysis.tldr.customer}\n"
        if analysis.tldr.summary:
            text += f"üìù {analysis.tldr.summary[:200]}...\n"
        text += "\n"

    # –†–∏—Å–∫-–∞–Ω–∞–ª–∏–∑
    if analysis.risk:
        risk_emoji = (
            "üü¢"
            if analysis.risk.level == "low"
            else "üü°" if analysis.risk.level == "medium" else "üî¥"
        )
        text += f"{risk_emoji} <b>–†–∏—Å–∫: {analysis.risk.level.upper()}</b> ({analysis.risk.score:.2f})\n"
        if analysis.risk.explanation:
            text += f"‚ö†Ô∏è {analysis.risk.explanation[:150]}...\n"
        text += "\n"

    # –§–∏–Ω–∞–Ω—Å—ã
    if analysis.finance:
        text += "üíµ <b>–ù–î–° –∞–Ω–∞–ª–∏–∑:</b>\n"
        text += f"–°—É–º–º–∞ –±–µ–∑ –ù–î–°: {analysis.finance.amount_without_vat:,.0f} —Ç–≥\n"
        text += f"–ù–î–° ({analysis.finance.vat_rate*100:.0f}%): {analysis.finance.vat_amount:,.0f} —Ç–≥\n"
        text += f"–ò—Ç–æ–≥–æ —Å –ù–î–°: {analysis.finance.total_with_vat:,.0f} —Ç–≥\n\n"

    # –û—à–∏–±–∫–∏
    if analysis.errors:
        text += f"‚ö†Ô∏è –û—à–∏–±–∫–∏: {', '.join(analysis.errors[:2])}\n"

    return text
