import asyncio
import logging
import os
from contextlib import asynccontextmanager

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.filters import Command, CommandStart
from aiogram.types import Message
from aiogram.utils.markdown import hbold, hcode
from client import ZakupaiAPIClient
from db_simple import get_api_key, init_db, save_api_key

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
TOKEN = os.getenv("TELEGRAM_BOT_TOKEN") or os.getenv("TELEGRAM_TOKEN")
if not TOKEN:
    raise ValueError("TELEGRAM_BOT_TOKEN –∏–ª–∏ TELEGRAM_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

# –í–∞–ª–∏–¥–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–∞ –≤ dev —Ä–µ–∂–∏–º–µ
if TOKEN.endswith("_") or "AAAA" in TOKEN:
    logger.warning(
        "‚ö†Ô∏è  –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è dev/placeholder —Ç–æ–∫–µ–Ω - –±–æ—Ç –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –≤ —Ä–µ–∂–∏–º–µ –∑–∞–≥–ª—É—à–∫–∏"
    )
    DEV_MODE = True
else:
    DEV_MODE = False

bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()

# API –∫–ª–∏–µ–Ω—Ç
api_client = ZakupaiAPIClient(
    base_url=os.getenv("ZAKUPAI_API_URL", "http://localhost:8080"),
    api_key=os.getenv("ZAKUPAI_API_KEY", ""),
)


@dp.message(CommandStart())
async def command_start_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start
    """
    user_id = message.from_user.id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ API –∫–ª—é—á–∞
    api_key = await get_api_key(user_id)

    if not api_key:
        await message.answer(
            f"üëã –ü—Ä–∏–≤–µ—Ç, {hbold(message.from_user.full_name)}!\n\n"
            "üîë –î–ª—è —Ä–∞–±–æ—Ç—ã —Å ZakupAI –Ω—É–∂–µ–Ω API –∫–ª—é—á.\n"
            f"–û—Ç–ø—Ä–∞–≤—å –º–Ω–µ –∫–æ–º–∞–Ω–¥—É: {hcode('/key YOUR_API_KEY')}\n\n"
            "–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—ã:\n"
            f"‚Ä¢ {hcode('/lot <id|url>')} - –∞–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞\n"
            f"‚Ä¢ {hcode('/help')} - —Å–ø—Ä–∞–≤–∫–∞"
        )
    else:
        await message.answer(
            f"‚úÖ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω–æ, {hbold(message.from_user.full_name)}!\n\n"
            "üöÄ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
            f"‚Ä¢ {hcode('/lot <id|url>')} - –∞–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞\n"
            f"‚Ä¢ {hcode('/key <–Ω–æ–≤—ã–π_–∫–ª—é—á>')} - –æ–±–Ω–æ–≤–∏—Ç—å API –∫–ª—é—á\n"
            f"‚Ä¢ {hcode('/help')} - —Å–ø—Ä–∞–≤–∫–∞"
        )


@dp.message(Command("key"))
async def command_key_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /key –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è API –∫–ª—é—á–∞
    """
    user_id = message.from_user.id

    # –ò–∑–≤–ª–µ–∫–∞–µ–º API –∫–ª—é—á –∏–∑ –∫–æ–º–∞–Ω–¥—ã
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer(
            "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–º–∞–Ω–¥—ã.\n" f"–ò—Å–ø–æ–ª—å–∑—É–π: {hcode('/key YOUR_API_KEY')}"
        )
        return

    api_key = args[1].strip()

    if len(api_key) < 10:  # –ë–∞–∑–æ–≤–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è
        await message.answer("‚ùå API –∫–ª—é—á —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π")
        return

    try:
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º API –∫–ª—é—á
        await save_api_key(user_id, api_key)

        if DEV_MODE:
            await message.answer("‚úÖ API –∫–ª—é—á —Å–æ—Ö—Ä–∞–Ω—ë–Ω (dev —Ä–µ–∂–∏–º)")
        else:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –∫–ª—é—á–∞
            test_client = ZakupaiAPIClient(
                base_url=os.getenv("ZAKUPAI_API_URL", "http://localhost:8080"),
                api_key=api_key,
            )

            health_check = await test_client.health_check()
            if health_check and health_check.get("status") == "ok":
                await message.answer("‚úÖ API –∫–ª—é—á —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∏ –ø—Ä–æ–≤–µ—Ä–µ–Ω!")
            else:
                await message.answer("‚ö†Ô∏è API –∫–ª—é—á —Å–æ—Ö—Ä–∞–Ω—ë–Ω, –Ω–æ –Ω–µ –ø—Ä–æ—à—ë–ª –ø—Ä–æ–≤–µ—Ä–∫—É")

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è API –∫–ª—é—á–∞ –¥–ª—è {user_id}: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è API –∫–ª—é—á–∞")


@dp.message(Command("lot"))
async def command_lot_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /lot –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞
    """
    user_id = message.from_user.id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º API –∫–ª—é—á
    api_key = await get_api_key(user_id)
    if not api_key:
        await message.answer(
            "üîë –°–Ω–∞—á–∞–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏ API –∫–ª—é—á:\n" f"{hcode('/key YOUR_API_KEY')}"
        )
        return

    # –ò–∑–≤–ª–µ–∫–∞–µ–º ID –ª–æ—Ç–∞
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        await message.answer(
            "‚ùå –£–∫–∞–∂–∏ ID –∏–ª–∏ URL –ª–æ—Ç–∞.\n" f"–ü—Ä–∏–º–µ—Ä: {hcode('/lot 12345')}"
        )
        return

    lot_input = args[1].strip()

    # –ò–∑–≤–ª–µ–∫–∞–µ–º ID –∏–∑ URL –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    lot_id = extract_lot_id(lot_input)
    if not lot_id:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å ID –ª–æ—Ç–∞")
        return

    if DEV_MODE:
        await message.answer("üîÑ Dev —Ä–µ–∂–∏–º: —ç–º—É–ª—è—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞...")
        # –≠–º—É–ª—è—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤ dev —Ä–µ–∂–∏–º–µ
        dev_result = {
            "lot_id": lot_id,
            "tldr": {
                "title": f"–¢–µ—Å—Ç–æ–≤—ã–π –ª–æ—Ç {lot_id}",
                "price": "1000000",
                "customer": "–¢–µ—Å—Ç–æ–≤—ã–π –∑–∞–∫–∞–∑—á–∏–∫",
            },
            "risk": {"score": 0.3, "explanation": "–°—Ä–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞ (dev)"},
            "finance": {
                "amount_without_vat": "892857",
                "vat_amount": "107143",
                "total_with_vat": "1000000",
            },
        }
        formatted_result = format_lot_analysis(dev_result)
        await message.answer(formatted_result)
    else:
        await message.answer("üîÑ –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –ª–æ—Ç...")

        try:
            # –°–æ–∑–¥–∞—ë–º –∫–ª–∏–µ–Ω—Ç —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–º API –∫–ª—é—á–æ–º
            user_client = ZakupaiAPIClient(
                base_url=os.getenv("ZAKUPAI_API_URL", "http://localhost:8080"),
                api_key=api_key,
            )

            # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞
            result = await analyze_lot_pipeline(user_client, lot_id)

            # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            formatted_result = format_lot_analysis(result)
            await message.answer(formatted_result)

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞ {lot_id} –¥–ª—è {user_id}: {e}")
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞")


@dp.message(Command("help"))
async def command_help_handler(message: Message) -> None:
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /help
    """
    help_text = (
        "ü§ñ ZakupAI Telegram Bot\n\n"
        "üìã –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
        f"‚Ä¢ {hcode('/start')} - –Ω–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É\n"
        f"‚Ä¢ {hcode('/key <api_key>')} - —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å API –∫–ª—é—á\n"
        f"‚Ä¢ {hcode('/lot <id|url>')} - –∞–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞\n"
        f"‚Ä¢ {hcode('/help')} - —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n\n"
        "üîç –ü—Ä–∏–º–µ—Ä –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞:\n"
        f"{hcode('/lot 12345')}\n"
        f"{hcode('/lot https://goszakup.gov.kz/ru/announce/index/12345')}\n\n"
        "üîß –ü–æ–¥–¥–µ—Ä–∂–∫–∞: @zakupai_support"
    )
    await message.answer(help_text)


def extract_lot_id(lot_input: str) -> str:
    """
    –ò–∑–≤–ª–µ–∫–∞–µ—Ç ID –ª–æ—Ç–∞ –∏–∑ —Å—Ç—Ä–æ–∫–∏ (ID –∏–ª–∏ URL)
    """
    import re

    # –ï—Å–ª–∏ —ç—Ç–æ —É–∂–µ —á–∏—Å–ª–æ
    if lot_input.isdigit():
        return lot_input

    # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–∑ URL
    url_patterns = [
        r"/announce/index/(\d+)",
        r"/lot/(\d+)",
        r"lot_id=(\d+)",
        r"id=(\d+)",
    ]

    for pattern in url_patterns:
        match = re.search(pattern, lot_input)
        if match:
            return match.group(1)

    return ""


async def analyze_lot_pipeline(client: ZakupaiAPIClient, lot_id: str) -> dict:
    """
    –ü–æ–ª–Ω—ã–π –ø–∞–π–ø–ª–∞–π–Ω –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞
    """
    result = {
        "lot_id": lot_id,
        "tldr": None,
        "risk": None,
        "finance": None,
        "error": None,
    }

    try:
        # 1. TL;DR —á–µ—Ä–µ–∑ doc-service
        tldr_data = await client.get_tldr(lot_id)
        result["tldr"] = tldr_data

        # 2. –†–∏—Å–∫-–∞–Ω–∞–ª–∏–∑
        risk_data = await client.get_risk_score(lot_id)
        result["risk"] = risk_data

        # 3. –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —Ä–∞—Å—á—ë—Ç—ã (–ø—Ä–∏–º–µ—Ä —Å –ù–î–°)
        if tldr_data and "price" in tldr_data:
            vat_data = await client.calculate_vat(tldr_data["price"])
            result["finance"] = vat_data

    except Exception as e:
        result["error"] = str(e)

    return result


def format_lot_analysis(result: dict) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
    """
    lot_id = result["lot_id"]

    if result.get("error"):
        return f"‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –ª–æ—Ç–∞ {lot_id}: {result['error']}"

    output = [f"üìä –ê–Ω–∞–ª–∏–∑ –ª–æ—Ç–∞ {hbold(lot_id)}"]

    # TL;DR
    if result.get("tldr"):
        tldr = result["tldr"]
        output.append(f"\nüìù {hbold('–ö—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ:')}")
        output.append(f"‚Ä¢ –ù–∞–∑–≤–∞–Ω–∏–µ: {tldr.get('title', 'N/A')}")
        output.append(f"‚Ä¢ –¶–µ–Ω–∞: {tldr.get('price', 'N/A')} —Ç–≥")
        output.append(f"‚Ä¢ –ó–∞–∫–∞–∑—á–∏–∫: {tldr.get('customer', 'N/A')}")

    # –†–∏—Å–∫-–∞–Ω–∞–ª–∏–∑
    if result.get("risk"):
        risk = result["risk"]
        risk_score = risk.get("score", 0)
        risk_level = (
            "üü¢ –ù–∏–∑–∫–∏–π"
            if risk_score < 0.3
            else "üü° –°—Ä–µ–¥–Ω–∏–π" if risk_score < 0.7 else "üî¥ –í—ã—Å–æ–∫–∏–π"
        )

        output.append(f"\n‚ö†Ô∏è {hbold('–†–∏—Å–∫-–∞–Ω–∞–ª–∏–∑:')}")
        output.append(f"‚Ä¢ –£—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: {risk_level} ({risk_score:.2f})")
        if "explanation" in risk:
            output.append(f"‚Ä¢ –ü—Ä–∏—á–∏–Ω—ã: {risk['explanation']}")

    # –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —Ä–∞—Å—á—ë—Ç—ã
    if result.get("finance"):
        finance = result["finance"]
        output.append(f"\nüí∞ {hbold('–§–∏–Ω–∞–Ω—Å—ã:')}")
        output.append(f"‚Ä¢ –°—É–º–º–∞ –±–µ–∑ –ù–î–°: {finance.get('amount_without_vat', 'N/A')} —Ç–≥")
        output.append(f"‚Ä¢ –ù–î–° (12%): {finance.get('vat_amount', 'N/A')} —Ç–≥")
        output.append(f"‚Ä¢ –ò—Ç–æ–≥–æ —Å –ù–î–°: {finance.get('total_with_vat', 'N/A')} —Ç–≥")

    return "\n".join(output)


@asynccontextmanager
async def lifespan_context():
    """
    –ö–æ–Ω—Ç–µ–∫—Å—Ç –∂–∏–∑–Ω–µ–Ω–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    """
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
    await init_db()
    logger.info("–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")

    yield

    logger.info("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞")


async def main() -> None:
    """
    –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞
    """
    async with lifespan_context():
        logger.info("–ó–∞–ø—É—Å–∫ ZakupAI Telegram Bot")
        await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())
